namespace Mirix
{
    namespace Interpreter
    {
        namespace Parser
        {

            using System.Collections.Generic;
            using System;
            using Instructions;
            using Data.Code;

            //The Parser
            //Generates code
            public sealed class Parser
            {
                //Returns a Block[]
                public static Block[] parse(Lexer.Token[] tokens)
                {
                    //The working set of Instructions
                    List<Block> blocks = new List<Block>();

                    //Begin to look for the keyword `function` then a `name` then `{`
                    //then start generating code for this function in there and stop when
                    //we encounter a `}`.
                    //Repeat this process

                    //Whether an error occurred during parsing
                    bool error = false;

                    //The current presepctive
                    int expectationIndex = 0;

                    //Loop through the tokens and build instructions
                    int tokenIndex = 0;
                    while(tokenIndex < tokens.Length)
                    {
                        //Current token
                        string currentToken = tokens[tokenIndex].getToken();


                        //First expect the keyword `function`
                        if(expectationIndex == 0)
                        {
                           if(currentToken.Equals("function"))
                           {
                               //If we get the keyword `function` then we can go ahead
                               continue;
                           }
                           else
                           {
                               Console.Out.WriteLine("Expected function, got \""+currentToken+"\".");
                               error = true;
                               break;
                           }
                        }
                        //Secondly expect the a name for the function
                        else if(expectationIndex == 1)
                        {
                            //The function's (code block's) name
                            string functionName = currentToken;

                            //The function (CodeBlock) generated by the `parseFunction` which we pass a reference to the variable i (index)
                            //so that when we come back we are pointing to the next token which should be the keyword `function`
                            Block functionBlock = parseFunction(ref tokenIndex);
                            tokens.AsSpan();//TODO cotinue here
                        }

                        Console.Out.WriteLine("Currently processing token \""+currentToken+"\"");

                        //Check if any errors occurred
                        if(error)
                        {
                            Console.Out.WriteLine("Errors occurred during parsing.");
                        }
                        else
                        {
                            //All is good
                            Console.Out.WriteLine("Parsing succeeded");
                        }
                    }


                    return blocks.ToArray();
                }

                private Block parseFunction(ref int tokenIndex, string functionName, )
                {
                    //The generated Block
                    Block generatedBlock = new Block();
                    //TODO: Add function parsing code here

                    //Begin by expecting a `{`

                    //Parse in between

                    //End when we come accross a `}`     
                }
            }

           
        }
    }
}