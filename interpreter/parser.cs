namespace Mirix
{
    namespace Interpreter
    {
        namespace Parser
        {

            using System.Collections.Generic;
            using System;
            using Instructions;
            using Data.Code;
            using Lexer;

            //The Parser
            //Generates code
            public sealed class Parser
            {
                //Returns a Block[]
                public static Block[] parse(Token[] tokens)
                {
                    //The working set of Instructions
                    List<Block> blocks = new List<Block>();

                    //Begin to look for the keyword `function` then a `name` then `{`
                    //then start generating code for this function in there and stop when
                    //we encounter a `}`.
                    //Repeat this process

                    //Whether an error occurred during parsing
                    bool error = false;

                    //The current presepctive
                    int expectationIndex = 0;

                    //Loop through the tokens and build instructions
                    int tokenIndex = 0;
                    while (tokenIndex < tokens.Length)
                    {
                        //Current token
                        string currentToken = tokens[tokenIndex].getToken();

                        //First expect the keyword `function`
                        if (expectationIndex == 0)
                        {
                            if (currentToken.Equals("function"))
                            {
                                //If we get the keyword `function` then we can go ahead
                                //TODO: Remove me after halt test
                                Console.Out.WriteLine("HALT");
                                continue;
                            }
                            else
                            {
                                Console.Out.WriteLine("Expected function, got \"" + currentToken + "\".");
                                error = true;
                                break;
                            }
                        }
                        //Secondly expect the a name for the function
                        else if (expectationIndex == 1)
                        {
                            //The function's (code block's) name
                            string functionName = currentToken;
                            Console.Out.WriteLine("Function's name: \"" + functionName + "\"");



                            //The function (CodeBlock) generated by the `parseFunction` which we pass a reference to the variable i (index)
                            //so that when we come back we are pointing to the next token which should be the keyword `function`
                            Block functionBlock = parseFunction(ref tokenIndex, functionName, tokens, ref error);

                            //Check for an error (if there was one during the function block parsing)
                            if (error)
                            {
                                Console.Out.WriteLine("It is reported that there was an error in the `parseFunction` parsing of the function block.");
                                break;
                            }

                            tokens.AsSpan();//TODO cotinue here
                        }

                        Console.Out.WriteLine("Currently processing token \"" + currentToken + "\"");

                        //Check if any errors occurred
                        if (error)
                        {
                            Console.Out.WriteLine("Errors occurred during parsing.");
                        }
                        else
                        {
                            //All is good
                            Console.Out.WriteLine("Parsing succeeded");
                        }
                    }


                    return blocks.ToArray();
                }

                private static Block parseFunction(ref int tokenIndex, string functionName, Token[] tokens, ref bool error)
                {
                    //The generated Block
                    Block generatedBlock = null;

                    //What we are expecting
                    int expectationIndex = 0;

                    //Loop through the array of tokens
                    while (tokenIndex < tokens.Length)
                    {
                        //Current token
                        string currentToken = tokens[tokenIndex].getToken();

                        //Begin by expecting a `{`
                        if (expectationIndex == 0)
                        {
                            if (currentToken.Equals("{"))
                            {
                                tokenIndex++;
                                continue;
                            }
                            else
                            {
                                Console.Out.WriteLine("Expected \"{\" but got \"" + currentToken + "\"");
                                error = true;
                                break;
                            }

                        }
                    }


                    //Parse in between

                    //End when we come accross a `}`

                    return generatedBlock;
                }
            }
        }
    }
}